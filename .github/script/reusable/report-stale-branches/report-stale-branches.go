package main

import (
	"bytes"
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/google/go-github/v69/github"
)

const (
	issueTitle          = ":broom: Stale branches"
	issueBodyIdentifier = "<!-- gha:report-stale-branches -->"
)

type staleBranch struct {
	name                string
	author              string
	date                string
	timeSinceLastCommit string
}

var (
	gh                      *github.Client
	githubRepository        = os.Getenv("GITHUB_REPOSITORY")
	repoOwner               string
	repoName                string
	ghToken                 = os.Getenv("GH_TOKEN")
	issueBody               string
	repo                    *git.Repository
	staleBranches           []staleBranch
	daysBeforeStale         = 30
	atLeastOneBranchIsStale = false
)

func initLogger() {
	var logLevel slog.Level
	if os.Getenv("RUNNER_DEBUG") == "1" {
		logLevel = slog.LevelDebug
	} else {
		logLevel = slog.LevelInfo
	}
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: logLevel})))
}

func checkAndSetVariables() error {
	slog.Debug("START checkAndSetVariables")
	if githubRepository == "" {
		return fmt.Errorf("GITHUB_REPOSITORY is not set")
	}
	repoOwner = strings.Split(githubRepository, "/")[0]
	repoName = strings.Split(githubRepository, "/")[1]
	if ghToken == "" {
		return fmt.Errorf("GH_TOKEN is not set")
	}
	if days, exists := os.LookupEnv("DAYS_BEFORE_STALE"); exists {
		daysBeforeStale, _ = strconv.Atoi(days)
	}
	slog.Debug("END checkAndSetVariables", slog.Group("variables", slog.Any("githubRepository", githubRepository), slog.Int("daysBeforeStale", daysBeforeStale)))
	return nil
}

func initGithubClient() {
	slog.Debug("START initGithubClient")
	gh = github.NewClient(nil).WithAuthToken(ghToken)
	slog.Debug("END initGithubClient")
}

func initGitClient() error {
	slog.Debug("START initGitClient")
	r, err := git.PlainOpenWithOptions(".", &git.PlainOpenOptions{DetectDotGit: true})
	if err != nil {
		return err
	}
	repo = r
	slog.Debug("END initGitClient")
	return nil
}

func listStaleBranches() error {
	slog.Debug("START listStaleBranches")
	head, err := repo.Head()
	if err != nil {
		return err
	}
	currentBranch := head.Name()
	slog.Info("Current branch", slog.String("currentBranch", currentBranch.Short()))
	branches, err := repo.Branches()
	if err != nil {
		return err
	}

	err = branches.ForEach(func(branch *plumbing.Reference) error {
		if branch.Name() != currentBranch {
			cIter, err := repo.Log(&git.LogOptions{From: branch.Hash()})
			if err != nil {
				return err
			}
			commits, err := cIter.Next()
			if err != nil {
				return err
			}
			lastCommitDate := commits.Author.When.Format("2006-01-02")
			daysSinceLastCommit := time.Since(commits.Author.When).Hours() / 24
			if daysSinceLastCommit >= float64(daysBeforeStale) {
				atLeastOneBranchIsStale = true
				author := commits.Author.Name

				staleBranches = append(staleBranches, staleBranch{name: branch.Name().Short(), author: author, date: lastCommitDate, timeSinceLastCommit: strconv.Itoa(int(daysSinceLastCommit))})
				slog.Info("Stale branch found", slog.String("branch", branch.Name().Short()), slog.String("author", author), slog.String("lastCommitDate", lastCommitDate), slog.String("timeSinceLastCommit", strconv.Itoa(int(daysSinceLastCommit))))
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	slog.Debug("END listStaleBranches", slog.Group("staleBranches", slog.Any("staleBranches", staleBranches)))
	return nil
}

func computeIssueBody() {
	slog.Debug("START computeIssueBody")
	var buffer bytes.Buffer
	buffer.WriteString(issueBodyIdentifier + "\n")
	buffer.WriteString("<!-- This issue is auto-generated by a workflow, do not edit manually -->\n")
	if !atLeastOneBranchIsStale {
		buffer.WriteString("## :confetti_ball: No stale branch found\n")
	} else {
		buffer.WriteString("## :broom: Consider deleting the following stale branches\n\n")
		buffer.WriteString("> [!TIP]\n")
		buffer.WriteString("> Deleted branches can be restored anytime from [here](../activity?activity_type=branch_deletion)\n\n")
		buffer.WriteString("| Branch Name | Author | Last Commit Date |\n")
		buffer.WriteString("| ----------- | ------ | ---------------- |\n")
		for i, branch := range staleBranches {
			branchNameWithLink := fmt.Sprintf("[%s](https://github.com/%s/tree/%s)", branch.name, githubRepository, branch.name)
			buffer.WriteString(fmt.Sprintf("| %s | @%s | %s (%s days) |\n", branchNameWithLink, staleBranches[i].author, staleBranches[i].date, staleBranches[i].timeSinceLastCommit))
		}
		buffer.WriteString("\n> [!NOTE]\n")
		buffer.WriteString("> Author might not be relevant if the committer did not configure git to use their GitHub username.\n")
	}
	issueBody = buffer.String()
	slog.Info("Issue body computed", slog.String("issueBody", issueBody))
	slog.Debug("END computeIssueBody", slog.String("issueBody", issueBody))
}

func createOrUpdateIssue() error {
	slog.Debug("START createOrUpdateIssue")
	issueNumber, err := getIssueNumber()
	if err != nil {
		return err
	}
	if issueNumber == -1 {
		slog.Info("Issue not found, creating a new one")
		issueNumber, err = createIssue()
		if err != nil {
			return err
		}
		slog.Info("Issue created", slog.Int("issueNumber", issueNumber))
	} else {
		updateIssue(issueNumber)
	}
	pinIssue(issueNumber)
	slog.Debug("END createOrUpdateIssue", slog.Int("issueNumber", issueNumber))
	return nil
}

func main() {
	startTime := time.Now()
	defer func() {
		slog.Debug("Execution time", slog.String("duration", time.Since(startTime).String()))
	}()
	initLogger()
	err := checkAndSetVariables()
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	initGithubClient()
	err = initGitClient()
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	err = listStaleBranches()
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	computeIssueBody()
	err = createOrUpdateIssue()
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	slog.Info("Workflow completed successfully")
}

func getIssueNumber() (int, error) {
	slog.Debug("START getIssueNumber")
	issues, resp, err := gh.Search.Issues(context.TODO(), "is:issue in:title "+issueTitle+" repo:"+githubRepository, nil)
	if err != nil {
		return -1, err
	}
	if resp.StatusCode != 200 {
		return -1, fmt.Errorf("Failed to search issues")
	}
	issueNumber := -1
	for _, issue := range issues.Issues {
		if strings.Contains(issue.GetBody(), issueBodyIdentifier) {
			issueNumber = issue.GetNumber()
			slog.Info("Issue found", slog.Int("issueNumber", issueNumber))
			break
		}
	}
	slog.Debug("END getIssueNumber", slog.Int("issueNumber", issueNumber))
	return issueNumber, nil
}

func createIssue() (int, error) {
	slog.Debug("START createIssue")
	i := github.IssueRequest{
		Title: github.Ptr(issueTitle),
		Body:  &issueBody,
	}
	issue, resp, err := gh.Issues.Create(context.TODO(), repoOwner, repoName, &i)
	if err != nil {
		return -1, err
	}
	if resp.StatusCode != 201 {
		return -1, fmt.Errorf("Failed to create issue")
	}
	issueNumber := issue.GetNumber()
	slog.Debug("END createIssue", slog.Int("issueNumber", issueNumber))
	return issueNumber, nil
}

func updateIssue(issueNumber int) error {
	slog.Debug("START updateIssue")
	var issueDesiredStatus string
	if atLeastOneBranchIsStale {
		issueDesiredStatus = "open"
	} else {
		issueDesiredStatus = "closed"
	}
	i := github.IssueRequest{
		Body:  &issueBody,
		State: github.Ptr(issueDesiredStatus),
	}
	_, resp, err := gh.Issues.Edit(context.TODO(), repoOwner, repoName, issueNumber, &i)
	if err != nil {
		return err
	}
	if resp.StatusCode != 200 {
		return fmt.Errorf("Failed to update issue")
	}
	slog.Info("Issue updated", slog.Int("issueNumber", issueNumber))
	slog.Debug("END updateIssue")
	return nil
}

func pinIssue(issueNumber int) {
	slog.Debug("START pinIssue")
	exec.Command("gh", "issue", "pin", strconv.Itoa(issueNumber)).Run()
	slog.Info("Issue pinned", slog.Int("issueNumber", issueNumber))
	slog.Debug("END pinIssue")
}
